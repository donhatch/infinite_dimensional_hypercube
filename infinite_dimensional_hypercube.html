<html>
  <head>
    <title>Infinite dimensional hypercube</title>
  </head>
  <body>
    <svg style="width:1024px; height:1024px; border: 1px solid black;">
      <circle cx="512" cy="512" r="512" style="stroke:red; fill:none;" />
      <g id="theG" transform="translate(512,512) scale(1,-1)" >
      </g>
    </svg>
  </body>
  <script>
    (()=>{
      "use strict";
      console.log("in script");
      const theG = document.getElementById("theG");
      console.log("theG = ",theG);
      let innerHTML = "";

      const circle = (cx,cy,r) => '<circle cx="'+cx+'" cy="'+cy+'" r="'+r+'" style="stroke:black; fill:white;" />';
      const seg = (x0,y0,x1,y1) => '<path d="M'+x0+','+y0+' L'+x1+','+y1+'" style="stroke:black; fill:none;" />';

      const vpv = (a,b) => {
        const answer = [];
        for (let i = 0; i < a.length; ++i) {
          answer.push(a[i]+b[i]);
        }
        return answer;
      };  // vpv
      const vxm = (v,m) => {
        const answer = [];
        for (let i = 0; i < m[0].length; ++i) {
          let sum = 0.;
          for (let j = 0; j < v.length; ++j) {
            sum += v[j]*m[j][i];
          }
          if (m.length > v.length)
            sum += m[v.length][i];
          answer.push(sum);
        }
        return answer;
      };  // vxm
      const extrude = (verts0,edges0,extrusionvec) => {
        const verboseLevel = 0;
        if (verboseLevel >= 1) console.log("in extrude");
        const verts = [];
        const edges = [];
        for (const vert of verts0) {
          verts.push(vert);
        }
        for (const vert of verts0) {
          verts.push(vpv(vert, extrusionvec));
        }
        for (const edge of edges0) {
          edges.push(edge);
        }
        for (let i = 0; i < verts0.length; ++i) {
          edges.push([i, i+verts0.length]);
        }
        for (let i = 0; i < edges0.length; ++i) {
          edges.push([edges0[i][0]+verts0.length, edges0[i][1]+verts0.length]);
        }
        if (verboseLevel >= 1) console.log("  verts0 = "+verts0);
        if (verboseLevel >= 1) console.log("  edges0 = "+edges0);
        if (verboseLevel >= 1) console.log("  verts = "+verts);
        if (verboseLevel >= 1) console.log("  edges = "+edges);
        if (verboseLevel >= 1) console.log("  edges = ",edges);
        if (verboseLevel >= 1) console.log("out extrude");
        return [verts,edges];
      };  // extrude
      const vertRadius=3;
      const seedLength = 40;

      // Simple
      const extrusionvec = [0,seedLength];
      let extrusionvec1 = extrusionvec;

      let fixedVec;
      let imageOfYAxis;
      if (true)
      {
        fixedVec = [1,0];
        imageOfYAxis = [Math.sqrt(.5),Math.sqrt(.5)];
      }

      if (true)  // set to true to put an edge right on the fixed direction
      {
          extrusionvec1 = fixedVec;
      }

      let rowsquashmat;
      {
        // We want rowsquashmat such that:
        //   - fixedVec -> fixedVec  (some multiple)
        //   - y axis -> imageOfYaxis (some multiple)
        //   - bisector of fixedVec and y axis -> bisector of fixedVec and imageOfYaxis (some multiple)
        //   - in the limit, extrude followed by this operation should be the identity
        //
        // So:
        //   1. rotate the old bisector to the x axis
        //   2. scale in y so that old angle turns into new angle
        //   3. rotate x axis to new bisector
        //   4. scale so that... ?
      }

      if (false) {
        // 0 degrees -> 0 degrees
        // 90 -> 45
        const fudge = 1;
        rowsquashmat = [
          [1,0],
          [Math.sqrt(.5)*fudge,Math.sqrt(.5)*fudge],
        ];
        extrusionvec1 = [seedLength,0];
      } else {
        // -45 -> -45
        // 90 degrees -> 45 degrees
        const fudge = .5;
        rowsquashmat = [
          [1+Math.sqrt(.5)*fudge,-1+Math.sqrt(.5)*fudge],
          [Math.sqrt(.5)*fudge,Math.sqrt(.5)*fudge],
        ];
        extrusionvec1 = [seedLength*Math.sqrt(.5)*fudge,-seedLength*Math.sqrt(.5)*fudge]
      }

      const dim = 4;
      let verts = [[0,0]];
      let edges = [];
      for (let i = 0; i < dim; ++i) {
        // First squash
        for (let j = 0; j < verts.length; ++j) {
          verts[j] = vxm(verts[j], rowsquashmat);
        }
        // Then extrude
        if (i == 0)
          [verts,edges] = extrude(verts, edges, extrusionvec1);
        else
          [verts,edges] = extrude(verts, edges, extrusionvec);
      }

      for (const edge of edges) {
        innerHTML += seg(verts[edge[0]][0], verts[edge[0]][1], verts[edge[1]][0], verts[edge[1]][1]);
      }
      for (const vert of verts) {
        innerHTML += circle(vert[0], vert[1], vertRadius);
      }

      theG.innerHTML = innerHTML;
      console.log("out script");
    })();

</script>
</html>
